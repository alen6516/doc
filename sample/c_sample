# size of data type {
    void        1 byte
    char        1 byte
    short       2 bytes
    int         4 bytes
    float       4 bytes
    double      8 bytes
    long        8 bytes
    pointer     8 bytes
    NULL        8 bytes
    long double 16 bytes
    # C11 recommends to use int8_t, int16_t, int32_t, int64_t
    # uint8_t, uint16_t, uint32_t, uint64_t to avoid dependence problem.

    # on 32bit system
    sizeof(size_t) = sizeof(uintptr_t) = sizeof(intptr_t) = sizeof(ptrdiff_t) = 4

    # on 64bit system
    sizeof(size_t) = sizeof(uintptr_t) = sizeof(intptr_t) = sizeof(ptrdiff_t) = 8
# }


# cast pointer to int value {
    # intptr_t, uintptr_t are added in C99, they are used to store pointer value to int
    #include <inttypes.h>
    uint64_t var;
    uint64_t *ptr = &var;

    var = (uint64_t) ptr;       # on 64bit system it is fine
                                # but on 32bit system, u64 length is still 8 bytes but pointer length is 4
                                # so it will cause -Werror=pointer-to-int-cast
                                # we can use i686-linux-gnu-gcc to compile 32bit program

    # use this for portability:
    var = (uintptr_t) ptr;

    printf("0x%lu\n", var);     # on 64bit system it is fine
                                # but on 32bit system, u64 is long long unsign
                                # so it will cause -Werror=format

    # use PRId64/PRIu64 to represent ld/lu in 64bit system and lld/llu in 32bit system:
    printf("0x%" PRIu64 "\n",);
# }

# Compile flag to check 32 or 64 bit platform {
    # we cau use i686-linux-gnu-gcc to build 32bit program

    #if UINTPTR_MAX == 0xffFFffFF
    // 32-bit
    #elif UINTPTR_MAX == 0xffFFffFFffFFffFF
    // 64-bit
    #endif  // this way we don't need to add new compile flag

    #if _WIN64 || __amd64__
    // 32-bit
    #else
    // 64-bit
    #endif  // this way only works on x86 or amd64 chip, these flags are defined in preprocessor
# }

# Array {
    # declare
	# 不能用 = 來 assign 一個 array
	str = "string";		# error: assignment to expression with array type
	arr = {1, 2, 3}; 	# error: expected expression before ’ token
	str1 = str2; 		# error: assignment to expression with array type

	# 可以初始化 (在 declaration 時，這裡的 = 不是 assign)
	char s[10] = "string"; 	# 合法

	# 使用 == 來比較兩 array 是合法的，但不會產生預期結果 (兩者被視為 pointer 來比較，因為兩者 address 不同，所以不會相等)
	if ( str1 == str2 ) ... # no error

    # 未初始化的 array，裡面每個 char 的值不定，print 不出來，可能是 '\0' 也可能不是
    char s[5];
    printf("%s\n", s);  # 空的
    for (int i=0; i<5; i++) printf("%c", s[i] == '\0' ?'y':'n');    # nnnyy
    printf("");
    for (int i=0; i<5; i++) printf("%c", s[i] == ' ' ?'y':'n');     # nnnnn
    printf("");


	## size of int array
	int arr[] = {1, 2, 3};
	printf("%d\n", (int)sizeof(arr));	# 3 個 int => 12


	## size of char array
	char str[] = {'1', '2', '3'};
	printf("%d\n", (int)sizeof(str));	# 3 個 char => 3


	## size of string
	char str[] = "123";
	printf("%d\n", (int)sizeof(str));	# 結尾有一個 '\0' => 4

	char *str = "123";
	printf("%d\n", (int)sizeof(str)); 	# str 是 pointer!! => 8


    ## scanf a string
    char str[100];
    scanf(" %99[^\n]", str);
    ### first space is used to skip a ' ', '\t', '\n' in the input buffer left by the previous scanf
    ### %[^\n] means match a string not equal to '\n' and stores it (plus a '\0')
    ### 99 means at most read 99 chars from the input


	## int array shift
	int arr[] = {1, 2, 3};
	printf("%d\n", (arr+1)[1]);			# 出現 + 時，arr 視為 pointer ，arr+1 指向 2，而 (arr+1)[] 則又視為陣列 {2, 3} ，該陣列第 1 項 => 3
	printf("%d\n", (int)sizeof(arr+0));	# 出現 + 時，arr 視為 pointer => 8


	## char arr shift
	char *str = "abc";
	printf("%c\n", (str+1)[1]); 		# c
	printf("%d\n", sizeof(str+1));		# pointer => 8
	printf("%d\n", sizeof(str));		# pointer => 8


    ## use 
    char const *arr[] = {"abc", "def", "ghi"};
    # rather than
    char *arr[] = {"abc", "def", "ghi"};


    ## designated initializers
    int a[6] = { [4] = 29, [2] = 15 };
    # this is ISO C99 standard, also supported in gcc gnu89 as ab extension
    # is equivalent to int a[6] = { 0, 0, 15, 0, 0, 29, 0 }

    int widths[] = { [0 ... 9] = 1, [10 ... 99] = 2, [100] = 3 };
    # this is gcc extension
    # the length of the array will the highest value specified plus one.
 
    int whitespace[256]
       = { [' '] = 1, ['\t'] = 1, ['\h'] = 1,
           ['\f'] = 1, ['\n'] = 1, ['\r'] = 1 };


    ## array type cast
    int arr[3] = {1, 2, 3};
    int a[4] = (int[4]*) arr;
# }

# statement {
    ## switch case
    switch(n) {
        /* 
         * If want to declare variable in case
         * need to use {} to pack 
         */
        case 1: {
            int x;
            foo(x);
            return x;
        }
        case 2: {
            int x;
            bar(x);
            return x;
        }
    }

    ## ?:
    printf("%d\n", a ?: b);

    ## typeof()
    extern int foo();
    typedef(foo()) var;
    /* function foo will not be executed */
# }

# struct {
    ## pack
    struct foo {
        int id;
        char str[0];
    } __attribute__((packed));
    typedef struct foo Foo;

	## initialize
	struct inner {
		int a;
		char b;
	};

    struct inner in = {0, 'b'};

	struct outer {
		struct inner in;
		int c;
	}

	struct outer out = {
		.in = { 0, 'b'},
		.c = 0
	};

    ## for nested struct we don't need a struct name
    struct outer {
        struct {
            int a;
        } inner;
    };

    ## declare a local struct
    void foo()
    {
        struct {size_t x; char a[]; } *p;
        p = malloc(sizeof(*p) + 100);
    }
# }

# union {
    struct foo {
        union {
            int x;
            int y
        } value;
    };

    struct bar {
        union {
            int x;
            int y;
        };
    };

    struct foo foo;
    struct bar bar;
    foo.value.x = 10;
    bar.y = 10;
# }

# function {
    ## function pointer
    int *func(int num, char *str)
    {
        ...
    }
    int* (*func_pointer)(int, char*);
    func_pointer = &func;   # & can be omitted


    ## function pointer as a parameter in a function
    int func(int a2)
    {
        return a2; 
    }


    ## not using typedef
    int call_func(int (*call_this)(int))
    {
        int ret = call_this(5);
        return ret;
    }


    ## using typedef
    typedef int (*func_pointer)(int);
    int call_func(func_pointer call_this)
    {
        int ret = call_this(5);
        return ret;
    }

    int result = call_func(func);


    ## function pointer array
    void run() { printf("start\n"); }
    void stop() { printf("stop\n"); }
    void exit() { printf("exit\n"); }

    static void (*command[])(void) = {run, stop, exit};

    int OnStateChange(unsigned int state)
    {
        if (state > 3) {
            printf("Wrong state\n");
            return -1;
        }

        command[state]();
        return 0;
    }
# }

# printf {
    printf("%08x", 4779); # gives 000012ab
    printf("%08X", 4779); # gives 000012AB
    printf("%#08x", 4779); # gives 0x000012ab
# }

# get {
    #include <stdio.h>
    int fgetc (FILE *stream);
    # read next char from stream and return it as an unsigned char cast to an int, or EOF on end of file error


    char*  fgets (char *s, int size, FILE *stream);
    int getc (FILE *stream);
    # is equivalent to fgetc() except that it may be implemeted as a macro

    int getchar (void);
    char* gets (char *s);
    # Briefly, f-start API means this API is implemented by function rather than Macro.
    # However, in GUN C, these f-start API are also implemented by function, and just use a Macro to wrap it.
# }

# string {
    include <string.h>
    char str[3];
    memset(str, 'g', 3);
    printf("%s\n", str);    // "ggg"

    strncpy(str, "aa", 2);
    printf("%s\n", str);    // "aag"

    strncpy(str, "aa", 3);
    printf("%s\n", str);    // "aa"
# }

# bit operation {
    ## turn on a bit
    flag |= bit;

    ## turn off a bit
    flag &= ~bit;
# }

# date {
    ## format print
    include <time.h>
    time_t rawtime;
    time(&rawtime);
    struct tm *timeinfo = localtime ( &rawtime );

    char buf[80];
    strftime (buffer,80,"Now it's %I:%M%p.",timeinfo);
    puts(buffer);


    ## gettimeofday
    include <time.h>
    struct timeval   tv;
    struct timezone  tz;
    gettimeofday(&tv,&tz);	/* &tz could be NULL */

    printf("tv_sec:%d\n",tv.tv_sec);
    printf("tv_usec:%d\n",tv.tv_usec);
    printf("tz_minuteswest:%d\n",tz.tz_minuteswest);
    printf("tz_dsttime:%d\n",tz.tz_dsttime);


    ## clock time
    include <time.h>
    clock_t start_t, end_t;
    double total_t;
    start_t = clock();
    do_thing();
    end_t = clock();
    total_t = (double)(end_t - start_t) / CLOCKS_PER_SEC;
    printf("Total time taken by CPU: %f sec", total_t);
# }

# random number {
    include <stdlib.h>
    include <time.h>
    srand(time(NULL)); # if don't use srand(time(NULL)), the result of rand() will be the same 
    int a = (rand() % 100)+1;
# }

# fork {
    #include <stdio.h>
    #include <stdlib.h>
    #include <sys/types.h>
    #include <unistd.h>
    #include <sys/wait.h>
    pid_t pid;
    int status;

    if ((pid = fork()) < 0) {
        perror("fail to fork");
        exit(1);
    }

    /* Child */
    if (pid == 0) {
        exit(0);
	}

    /* Parent
     * Gives you time to observe the zombie using $ ps aux | grep 'Z'
	 * here child exits but parents have not called wait, so child become zombie
	 */
    sleep(10);

    /* ... and after that, parent wait(2)s its child's
     * exit status, and prints a relevant message. */
    pid = wait(&status);
    if (WIFEXITED(status))
        fprintf(stderr, "\n\t[%d]\tProcess %d exited with status %d.\n",
                (int) getpid(), pid, WEXITSTATUS(status));
# }

# process {
## process exit
    exit(int status)
        * all functions registered in atexit() and on_exit() are called
        * return status to caller (command line) 

    _exit(int status)
        * exit the process immediately
        * close all file descriptors
        * any children are inherited by process 1
        * the process's parent is sent a SIGCHLD signal
# }

# dump_stack {
    ## dump_stack()
        * in kernel space, we call dump_stack() to print function stack.
    ## backtrace()
        * in user space, we call backtrace() to print function stack.
        ```
        void *bt[1024];
        int bt_size;
        char **bt_syms;
        int i;

        bt_size = backtrace(bt, 1024);
        bt_syms = backtrace_symbols(bt, bt_size);
        for (i=1; i<bt_size; i++) {
            printf("%s\n", bt_syms[i]);
        }
        free(bt_syms);
        ```
# }

# pthread {
    ## pthread_join()
        * The pthread_join() subroutine blocks the calling thread until the specified threadid thread terminates.
        * join, mutex and condition variable are 3 synchronization ways of pthread
        * If a thread is created as detached.

    ## pthread_exit()
        * in main(), if main() finishes before threads it spawned exit, all its child threads are terminated, but if call pthread_exit() before finishing main(), it will block and support the threads before they are done.

    ## pthread mutex
    #// hang until acquiring the lock
    pthread_mutex_t count_lock = PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_lock(&count_lock);
    global_int++;
    pthread_mutex_unlock(&count_lock);

    ## pthread spin_lock
    pthread_spinlock_t spin_lock;
    pthread_spin_init(&spin_lock, PTHREAD_PROCESS_PRIVATE);
    # PTHREAD_PROCESS_PRIVATE means this spinlock is only shared among threads of the same process
    pthread_spin_lock(&spin_lock);
    do_thing();
    pthread_spin_unlock(&spin_lock);

    ## pthread spin_trylock
    #// return immitiately if not acquiring a lock
    pthread_spinlock_t spin_lock;
    pthread_spin_init(&spin_lock, PTHREAD_PROCESS_PRIVATE);
    if (pthread_spin_trylock(&spin_lock)) {
        do_thing()
        pthread_spin_unlock(&spin_lock);
    }

    ## pthread_cond_signal(&cond)
    #// - Send signal to another thread which is waiting by calling pthread_cond_wait(&cond)
    #// - If there are multuple threads waiting, only one thread will receive the signal, depends on the priority and waiting time
    #// - However, in some implementation it will send signals to multiple threads, so use a while loop to avoid multiple threads works 
    while(!condition) {
        pthread_cond_wait(&cond, &mut);
    }

    ## pthread_cond_wait(&cond)
    #// - Have to get lock first, and then can call wait to hang the thread.
    #// - Hang until receive signal from another thread.
    #// - Release lock.

    
    ## pthead_self()
    #// pthreads from the same process, shared the same pid but different pthread_self() 
    
    ## conclusion
    #// - When multiple process compete a lock, only one process acquire the lock.
    #// - Other processes will sleep, which means OS will mot schedule them.
    #// - If use spinlock, then process will not sleep.
    #// - Until the lock is release, OS will pick up the process with the highest priority to run from the waiting list.
    #// - In ISR context, it is not recommended to acquire lock because we don't know when we can get it, but ISR should be short.
# }

# Signal {
    #include <signal.h>
    bool KEEP = 1;

    void int_handler() {
        KEEP = 0;
        printf("bye\n");
    }

    void tstp_handler() {
        printf("press ctrl-z\n");
    }

    void* child_threade() {
        while(KEEP);
    }

    int main () {
        // handle ctrl-c
        signal(SIGINT, int_handler);

        // handle ctrl-z
        signal(SIGTSTP, tstp_handler);
        
        // set breakpoint in C code for gdb
        raise(SIGINT);
    }
# }

# completion {
    # a synchronization mechanism in kernel
    struct completion {
        unsigned int        done;
        wait_queue_head_t   wait;
    };

    # APIs:
    #define COMPLETION_INITIALIZER(work) { 0, __WAIT_QUEUE_HEAD_INITIALIZER((work).wait) }
    #define DECLARE_COMPLETION(work) struct completion work = COMPLETION_INITIALIZER(work)
    static inline void init_completion(struct completion *x)
    {
        x->done = 0;
        init_waitqueue_head(&x->wait);
    }
 
    ## wait APIs:
    void wait_for_completion(struct completion *x);
    int wait_for_completion_interruptible(struct completion *x);
    unsigned long wait_for_completion_timeout(struct completion *x, unsigned long timeout);
    unsigned long wait_for_completion_interruptible_timeout(struct completion *x, unsigned long timeout);

    ## wakeup APIs:
    void complete(struct completion *x);
    void complete_all(struct completion *x);

    ## example:
    {
        #include <linux/module.h>
        #include <linux/init.h>
         
        #include <linux/sched.h>
        #include <linux/kernel.h>
        #include <linux/fs.h>
        #include <linux/types.h>
        #include <linux/completion.h>
         
        MODULE_LICENSE("GPL");
         
        static int complete_major = 250;
        DECLARE_COMPLETION(g_comp);
         
        ssize_t complete_read(struct file *filp, char __user *buf, size_t count, loff_t *pos)  {
            printk(KERN_ERR "process %i (%s) going to sleep\n", current->pid,current->comm);
            wait_for_completion(&g_comp);
            printk(KERN_ERR "awoken %i (%s)\n", current->pid, current->comm);
            return 0;
        }
         
        ssize_t complete_write(struct file *filp, const char __user *buf,size_t count, loff_t *pos) {
            printk(KERN_ERR "process %i (%s) awakening the readers...\n", current->pid, current->comm);
            complete(&g_comp);
            return count;
        }
         
        struct file_operations complete_fops = {
            .owner = THIS_MODULE,
            .read  = complete_read,
            .write = complete_write,
        };
         
        int complete_init(void) {
            int result;
            result = register_chrdev(complete_major, "complete", &complete_fops);
            if(result < 0)
                return result;
            if(complete_major == 0)
                complete_major = result;
            return 0;
        }

        void complete_cleanup(void) {
            unregister_chrdev(complete_major, "complete");
        }

        module_init(complete_init);
        module_exit(complete_cleanup);
    }

    ## testing steps:
    1. mknod /dev/complete 創建 complete節點，在linux上驅動程序需要手動創建文件節點。
    2. insmod complete.ko 插入驅動模塊，這裏要注意的是，因爲我們的代碼中是手動分配的設備號，很可能被系統已經使用了，所以如果出現這種情況，查看/proc/devices文件。找一個沒有被使用的設備號。
    3. cat /dev/complete 用於讀該設備，調用設備的讀函數
    4. 打開另一個終端輸入 echo “hello” > /dev/complete 該命令用於寫入該設備。
# }

# Macro {
    ## if define
    ```
    #ifdef AAA
    #define LOG(...)    printf(__VA_ARGS__)
    #elif defined(BBB)
    #define LOG(...)    perror(__VA_ARGS__)
    #else
    #define LOG(...)
    #endif
    ```


    ## __VA_ARGS__
    #define my_printf(...) 			printf(__VA_ARGS__)
    #define my_printf(format, ...) 	printf(format, ##__VA_ARGS__)
        * when user call my_printf("without arg\n"), if we don't use "##", result will be printf(format, ) => one comma left
        * another ability if "##" is to stick 2 variables in macro


    ## print a macro and its content as a string
    #define AVG(a,b)    (a+b)/2
    #define GET_VARIABLE_STRING(x) #x
    #define GET_MACRO_CONTENT_STRING(macro) GET_VARIABLE_STRING(macro)
    printf("%s = %s = %d\n", GET_VARIABLE_STRING(AVG(2,4)), GET_MACRO_CONTENT_STRING(AVG(2,4)), AVG(2,4));
        * "AVG(2,4) = (2+4)/2 = 3"

    ## stringizing
    #define xstr(s) str(s)
    #define str(s) #s
    #define foo 4
    str (foo)
        * "foo"
    xstr (foo)
        * xstr (4)
        * str (4)
        * "4"

    ## build bug in preprocessor, we can use it to see if a compile flag is on
    ```
    #ifndef DEBUG
    #error Only Debug builds are supported
    #endif
    ```

    ## Use macro to define enum and switch case to print error code
    ```
    // The X-macro
    #define LIST_OF_ERRORS                             \
           X(ERROR_MSG_1, "Failed to open file.\n")    \
           X(ERROR_MSG_2, "Failed to read file.\n")    \
           X(ERROR_MSG_3, "Failed to execute abc.\n")

    // 1st definition of X to define enum error codes
    #define X(e, m) e,
    enum {
    LIST_OF_ERRORS
    };
    #undef X

    // 2nd definition of X to define cases in a switch
    void print_error(int e)
    {
    #define X(e, m) case e: printf("[ERROR] : code (%d)\n\t%s", e, m); break;
      switch(e) {
        LIST_OF_ERRORS
        default: printf("[ERROR] : unknown code (%d)\n", e);
      }
    #undef X
    }

    int main(void)
    {
      print_error(ERROR_MSG_2);
      print_error(ERROR_MSG_1);
      print_error(ERROR_MSG_3);
      print_error(10);

      return 0;
    }
    ```

    ## Macro to different function
    ```
    #define print(suffix, ...) print ## suffix (__VA_ARGS__)

    void print_alan(const char *s)
    {
        printf("alan: %s", s);
    }

    int main()
    {
        print(f, "123\n");      // call printf
        print(_alan, "123\n");  // call print_alan
    }
    ```

    ## Concatenation
    ```
    struct command
    {
      char *name;
      void (*function) (void);
    };

    #define COMMAND(NAME)  { #NAME, NAME ## _command }

    struct command commands[] =
    {
      COMMAND (quit),
      COMMAND (help),
      …
    };
    /***
    struct command commands[] =
    {
      { "quit", quit_command },
      { "help", help_command },
      …
    };
    ***/
    ```
# }

# String {
    # ========== 複製 ==========
    char *strcpy(char *s1, const char *s2)
    char *strncpy(char *s1, const char *s2, size_t n)

    # ========== 串接 ==========
    char *strcat(char *s1, const char *s2)
    char *strncat(char *s1, const char *s2, size_t n)

    # ========== 比較 ==========
    int char strcmp( const char *s1, const char *s2)
    int char strncmp( const char *s1, const char *s2, size_t n)

    # 計算長度
    size_t strlen(const char *s)

    # ========== 搜尋 ==========
    # 回傳在字串 s 中，字元 c 第一次出現位置的指標
    char *strchr(const char *s, int c)

    # 計算經過幾個字元會在字串 s1 中遇到屬於 s2 中的字元
    size_t strcspn(const char *s1, const char *s2)

    # 計算經過幾個字元會在字串 s1 中遇到不屬於 s2 中的字元
    size_t strspn(const char *s1, const char *s2)

    # 回傳在字串 s2 中的任何字元在 s1 第一次出現位置的指標
    char *strpbrk(const char *s1, const char *s2)

    # 回傳在字串 s 中，字元 c 最後一次出現位置的指標
    char *strrchr(const char *s, int c)

    # 回傳在字串 s2 在 s1 第一次出現位置的指標
    char *strstr(const char *s1, const char *s2)

    # 以字串 s2 的內容切割 s1
    char *strtok(char *s1, const char *s2)

    # ========== memory ==========
    # 從 s2 所指向的資料複製 n 個字元到 s1
    void *memcpy(void *s1, const void *s2, size_t n)

    # 從 s2 所指向的資料複製 n 個字元到 s1
    void *memmove(void *s1, const void *s2, size_t n)

    # 比較 s1 與 s2 前 n 個字元的資料
    int memcmp(const void *s1, const void *s2, size_t n)

    # 找出字元 c 在 s 前 n 個字元第一次出現的位置
    void *memchr(const void *s, int c, size_t n)

    # 將 s 中前 n 個字元全部設定為 c
    void *memset(void *s, int c, size_t n)
# }

# atomic {
    ## atomic API
    * diff between __sync* and __atomic*
        * __atomic* is newer
        * basically they are the same, just __atomic have a parameter to speficy the memory-order
        * ref: https://stackoverflow.com/questions/23446210/what-is-the-difference-between-the-sync-and-atomic-intrinsics-of-gcc


    ## _Atomic
    _Atomic int sum;
    #// C11 standard added
    #// managed by <stdatomic.h> and <threads.h>


    ## atomic_fetch_add
    include <stdatomic.h>
    include <threads.h>
    atomic_int counter;
    atomic_fetch_add(&counter, 1);
    #// C11
    #// defined in <stdatomic.h>


    ## gcc thread local variable
    __thread int id;
# }

# Misc {
    ## How to define 32-bit long 0xFFFFFFFF ?
    u32 = ~(u32)0;


    ## const* int vs int const*
    const int *p = &a;
    #// declare p a pointer to const int
    #// so *p = 5 is wrong, p++ is right
    #// same as int const *p = &a

    int *const p = &a;
    #// declare p a const pointer to int type
    #// *p = 5 is right, p++ is wrong
    #// when const is at the left-side of *, int is const; when const is at the right-side of *, pointer is const.


    ## volatile and const, the following 2 are the same
    volatile const int x;
    const volatile int x;


    ## convert str to int
    int a = (int) strtol(argv[1], NULL, 10);
    # or use atoi
    #include <stdlib.h>
    int a = atoi(str);


    ## swap
    #define SWAP(a, b) do {     \
        if (a != b) {           \
            a = a^b;            \
            b = a^b;            \
            a = a^b;            \
        }                       \
    } while (0)


    ## swap pointer 
    #define SWAP_POINTER(p1, p2) do {   \
        if (p1 != p2) {                 \
            p1 = (void*) ((unsigned long)p1^(unsigned long)p2);     \
            p2 = (void*) ((unsigned long)p1^(unsigned long)p2);     \
            p1 = (void*) ((unsigned long)p1^(unsigned long)p2);     \
        }                                                           \
    } while (0)

    ## readline
    #include <stdio.h>
    FILE *fp;
    char *line = NULL;
    size_t len = 0;     //
    ssize_t read;       // number of char I read

    fp = fopen("file", "r");
    if (!fp) exit(EXIT_FAILURE);

    // line = NULL and len = 0 will ask getline to malloc
    while (-1 != (read = getline(&line, &len, fp))) {
        printf("Retrieved line of length %zu:\n", read);
        printf("%s", line);
    }

    fclose(fp);

    ## build bug on compile time
    #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
# }
